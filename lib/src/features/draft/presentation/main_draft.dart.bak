import 'dart:async';

import 'package:fantasy_drum_corps/src/common_widgets/responsive_center.dart';
import 'package:fantasy_drum_corps/src/constants/app_sizes.dart';
import 'package:fantasy_drum_corps/src/features/draft/data/all_draft_picks.dart';
import 'package:fantasy_drum_corps/src/features/draft/domain/socket_events.dart';
import 'package:fantasy_drum_corps/src/features/fantasy_corps/domain/caption_enum.dart';
import 'package:fantasy_drum_corps/src/features/fantasy_corps/domain/caption_model.dart';
import 'package:fantasy_drum_corps/src/features/fantasy_corps/domain/fantasy_corps.dart';
import 'package:fantasy_drum_corps/src/utils/alert_dialogs.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:responsive_framework/responsive_breakpoints.dart';
import 'package:socket_io_client/socket_io_client.dart' as io;

const turnLength = 45;

class TourDraftContents extends ConsumerStatefulWidget {
  const TourDraftContents({
    Key? key,
    required this.tourId,
    required this.userId,
  }) : super(key: key);

  final String tourId;
  final String userId;

  @override
  ConsumerState createState() => _TourDraftContentsState();
}

class _TourDraftContentsState extends ConsumerState<TourDraftContents> {
  late io.Socket socket;
  List<DrumCorpsCaption>? availablePicks;
  int remainingTime = turnLength;
  int roundNumber = 0;
  String? currentPick;
  String? nextPick;
  Timer? turnTimer;
  bool canPick = false;

  final Lineup fantasyCorps = {};
  List<Caption> captionFilters = List.empty(growable: true);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: pagePadding,
      child: SingleChildScrollView(
        child: ResponsiveCenter(
          maxContentWidth: 1000,
          child: Column(
            children: [
              IntrinsicHeight(
                child: Flex(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  direction: MediaQuery.of(context).size.width < 800
                      ? Axis.vertical
                      : Axis.horizontal,
                  children: [
                    Flexible(
                      fit: FlexFit.tight,
                      child: TimerCard(remainingTime: remainingTime),
                    ),
                    Flexible(
                      fit: FlexFit.tight,
                      child: RoundCard(roundNumber: roundNumber),
                    ),
                    Flexible(
                      fit: FlexFit.tight,
                      flex: 2,
                      child: CurrentPickCard(
                        currentPick: currentPick,
                        nextPick: nextPick,
                      ),
                    ),
                  ],
                ),
              ),
              IntrinsicHeight(
                child: Flex(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  direction:
                      ResponsiveBreakpoints.of(context).smallerThan(TABLET)
                          ? Axis.vertical
                          : Axis.horizontal,
                  children: [
                    Flexible(
                      flex: 2,
                      fit: FlexFit.tight,
                      child: CaptionFilterCard(
                        onFilterSelected: _onFilterChanged,
                      ),
                    ),
                    Flexible(
                      flex: 3,
                      fit: FlexFit.tight,
                      child: AvailableCaptions(
                        canPick: canPick,
                        availableCaptions: availablePicks,
                        onCaptionSelected: _onCaptionSelected,
                      ),
                    ),
                  ],
                ),
              ),
              PlayerLineup(
                lineup: fantasyCorps,
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _onFilterChanged(checked, caption) {
    if (checked) {
      setState(() => captionFilters.add(caption));
    } else {
      setState(() => captionFilters.remove(caption));
    }
  }

  void _onCaptionSelected(DrumCorpsCaption drumCorpsCaption) {
    var existingPicks = fantasyCorps[drumCorpsCaption.caption];
    final takenSlots = existingPicks?.length ?? 0;

    if (takenSlots > 1) {
      showAlertDialog(
          context: context,
          title: 'No ${drumCorpsCaption.caption.name} slots available');
      return;
    }
    // Cancel timer if set
    turnTimer?.cancel();

    socket.emit(
        'clientSendsPick', {'pickId': drumCorpsCaption.drumCorpsCaptionId});
    setState(() {
      remainingTime = 0;
      if (existingPicks != null) {
        existingPicks.add(drumCorpsCaption.corps);
        fantasyCorps.addAll({drumCorpsCaption.caption: existingPicks});
      } else {
        fantasyCorps.addAll({
          drumCorpsCaption.caption: [drumCorpsCaption.corps]
        });
      }
    });
  }

  @override
  void dispose() {
    socket.disconnect();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    final tourId = widget.tourId;
    final userId = widget.userId;

    // Set empty lineup
    for (final caption in Caption.values) {
      fantasyCorps.addAll({caption: List.empty(growable: true)});
    }
    socket = io.io('http://localhost:3000');
    if (socket.connected) {
      socket.disconnect();
    }
    socket.onConnect((_) {
      // Emit identification
      socket
          .emit(CLIENT_SENDS_IDENTIFICATION, {'tourId': tourId, 'uid': userId});

      socket.on('serverSendsStartingPicks', (data) {
        final picks = data['startingPicks'] as List<dynamic>;
        // Set empty lineup
        for (final caption in Caption.values) {
          fantasyCorps.addAll({caption: List.empty(growable: true)});
        }
        final filteredPicks = startingDraftPicks
            .where((element) => picks.contains(element.drumCorpsCaptionId))
            .toList();
        setState(() {
          availablePicks = filteredPicks;
        });
      });

      socket.on('draftStateUpdated', (data) {
        final roundNumber = data['roundNumber'] as int;
        final picks = data['availablePicks'] as List<dynamic>;
        _updateDraftState(roundNumber, picks);
      });

      socket.on('draftTurnStart', (data) {
        debugPrint('turn is starting');
        setState(() {
          remainingTime = turnLength;
          String currentPickerId = data['currentPickerId'] as String;
          currentPick = data['currentTurn'] as String? ?? 'Anonymous';
          nextPick = data['nextTurn'] as String? ?? 'Anonymous';
          canPick = currentPickerId == userId;
        });
        turnTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
          if (remainingTime == 0) {
            socket.emit('clientTurnTimeOut');
            debugPrint('Clients turn timed out');
            setState(() {
              canPick = false;
            });
            // Make a random pick
            timer.cancel();
          } else {
            setState(() {
              remainingTime--;
            });
          }
        });
      });
      socket.on('draftOver', (_) {
        debugPrint('draft is over');
        turnTimer?.cancel();
        setState(() {
          canPick = false;
        });
        showAlertDialog(context: context, title: 'Draft Complete');
        // write corps lineup to firebase
      });
    });
  }

  void _updateDraftState(int currentRound, List<dynamic> pickIds) {
    final filteredPicks = startingDraftPicks
        .where((element) => pickIds.contains(element.drumCorpsCaptionId))
        .toList();
    setState(() {
      roundNumber = currentRound;
      availablePicks = filteredPicks;
    });
  }

  void _startTurn() {}

  void _endTurn() {}
}
